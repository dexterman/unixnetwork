I/O模型
---
###阻塞式I/O \[blocking I/O\]
>  默认情况下，所有的套接字都是阻塞的。进程在从调用recvfrom开始到它返回的整个时间内是被阻塞
>  的。

###非阻塞式I/O \[unblocking I/O\]
> 进程把一个套接字设置成非阻塞式在通知内核：当所请求的I/O操作非得把本进程投入睡眠才能完成时，
> 不要把进程投入睡眠，而是返回一个错误。

###I/O复用 \[I/O multiplexing\] （select和poll）
> 进程需要一种预先告知内核的能力，使得内核一旦发现进程指定的一个活多个I/O条件就绪（也就是说
> 输入已准备好被读取，或者描述符已能承接更多的输出），他就通知进程。这个能力称为I/O复用。

> 调用select或poll，阻塞在这个两个系统调用中的某一个上，而不是阻塞在真正的I/O系统调用上。

###信号驱动式 \[signal-driven I/O\] （SIGIO）
> 让内核在描述符就绪时发送SIGIO信号通知我们。

###异步I/O \[asynchronous I/O\] （POSIX的aio_系列函数）
> 告知内核启动某个操作，并让内核在整个操作（包括将数据从内核复制到我们的自己的缓冲区）完成后通知我们。

	与信号驱动模型的主要区别在于：
		信号驱动式I/O是由内核通知我们何时可以启动一个I/O操作，而异步I/O模型是有内核通知我们I/O操作何时完成。

